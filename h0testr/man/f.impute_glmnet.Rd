% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute.R
\name{f.impute_glmnet}
\alias{f.impute_glmnet}
\title{Impute missing values using \code{glmnet}.}
\usage{
f.impute_glmnet(
  state,
  config,
  is_log_transformed = NULL,
  f_imp = f.impute_unif_sample_lod,
  nfolds = 5,
  alpha = 1,
  measure = "mae",
  aug_mult = 0.33,
  aug_add = 0,
  aug_steps = 3,
  verbose = T
)
}
\arguments{
\item{state}{A list with elements like that returned by \code{f.read_data()}:
  \tabular{ll}{
    \code{expression} \cr \tab Numeric matrix with non-negative expression values. \cr
    \code{features}   \cr \tab A data.frame with feature meta-data for rows of expression. \cr
    \code{samples}    \cr \tab A data.frame with observation meta-data for columns of expression. \cr
  }
It is assumed that state$expression has been previously \code{log2(x+1)} transformed.}

\item{config}{List with configuration values. Does not use any keys so can pass empty list.}

\item{is_log_transformed}{Logical scalar: if \code{state$expression} has 
been log transformed.}

\item{f_imp}{Function to use for initial rough imputation.}

\item{nfolds}{Numeric (greater than or equal to 2) number of folds for 
cross-validation tuning of \code{lambda} value for \code{glmnet}.}

\item{alpha}{Numeric (between 0 and 1) number of trees in random forest.}

\item{measure}{Character in set \code{c("mae", "mse")}. Loss function used 
during cross-validation tuning of \code{lambda} value for \code{glmnet}.}

\item{aug_mult}{Numeric affine shift for training data augmentation.}

\item{aug_add}{Numeric affine shift for training data augmentation.}

\item{aug_steps}{Numeric (non-negative) number of augmentation steps. Set to
\code{0} to skip augmentation.}

\item{verbose}{Logical if \code{TRUE}, emits progress messages.}
}
\value{
A list with the following elements:
  \tabular{llll}{
    \code{state} \cr 
      \tab A list with the following elements: \cr
      \tab \code{expression} \cr 
      \tab \tab \tab Numeric matrix with non-negative expression values. \cr
      \tab \code{features}   \cr 
      \tab \tab \tab A data.frame with feature meta-data for rows of expression. \cr
      \tab \code{samples}    \cr 
      \tab \tab \tab A data.frame with observation meta-data for columns of expression. \cr
    \code{log} \cr 
      \tab A data.frame logging statistics for each fit. \cr
  }
}
\description{
Impute missing values using \code{glmnet} package.
}
\details{
Imputes missing values using a \code{glmnet::cv.glmnet} model trained 
    using observations in which the feature was expressed. Iterates through 
    features beginning with those having fewest missing values. If 
    \code{aug_steps > 0}, augments observations with affine transormed versions.
    This is meant to enable extrapolation outside of observed intensity 
    range. If \code{aug_steps > 0}, assumes expression data have been previously
    \code{log(x+1)} transformed. If you want \code{0} to be considered missing, 
    and have \code{0} in the data, do something like 
    \code{exprs[exprs \%in\% 0] <- NA} prior to imputing. Augmentation uses 
    \code{f.aug_mult()}.
}
\examples{
set.seed(101)
exprs <- h0testr::f.sim1(n_obs=20, n_feats=30)$mat
feats <- data.frame(feature_id=rownames(exprs))
samps <- data.frame(observation_id=colnames(exprs))
state <- list(expression=exprs, features=feats, samples=samps)
config <- list()

## example with untransformed data:
out <- h0testr::f.impute_glmnet(state, config, is_log_transformed=FALSE, verbose=FALSE)
state2 <- out$state
summary(c(state$expression))    ## Note number of NAs
summary(c(state2$expression))   ## Note number of NAs
head(state$expression)
round(head(state2$expression))
print(out$log)

## example with log-transformed data:
state$expression <- log2(state$expression + 1)
out <- h0testr::f.impute_glmnet(state, config, is_log_transformed=TRUE, verbose=FALSE)
state2 <- out$state
summary(c(state$expression))    ## Note number of NAs
summary(c(state2$expression))   ## Note number of NAs
head(state$expression)
round(head(state2$expression))
print(out$log)
}
