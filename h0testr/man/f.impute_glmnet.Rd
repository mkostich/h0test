% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute.R
\name{f.impute_glmnet}
\alias{f.impute_glmnet}
\title{Impute missing values using \code{glmnet}.}
\usage{
f.impute_glmnet(
  state,
  config,
  f_imp = f.impute_loess_logit,
  nfolds = 5,
  alpha = 1,
  measure = "mae",
  aug_mult = 0.33,
  aug_add = 0,
  aug_steps = 3,
  verbose = T
)
}
\arguments{
\item{state}{A list with elements like that returned by \code{f.read_data()}:
  \tabular{ll}{
    \code{expression} \cr \tab Numeric matrix with non-negative expression values. \cr
    \code{features}   \cr \tab A data.frame with feature meta-data for rows of expression. \cr
    \code{samples}    \cr \tab A data.frame with observation meta-data for columns of expression. \cr
  } 
It is assumed that state$expression has been previously \code{log2(x+1)} transformed.}

\item{config}{List with configuration settings.}

\item{f_imp}{Function to use for initial rough imputation.}

\item{nfolds}{Numeric (greater than or equal to 2) number of folds for 
cross-validation tuning of \code{lambda} value for \code{glmnet}.}

\item{alpha}{Numeric (between 0 and 1) number of trees in random forest.}

\item{measure}{Character in set \code{c("mae", "mse")}. Loss function used 
during cross-validation tuning of \code{lambda} value for \code{glmnet}.}

\item{aug_mult}{Numeric affine shift for training data augmentation.}

\item{aug_add}{Numeric affine shift for training data augmentation.}

\item{aug_steps}{Numeric (non-negative) number of augmentation steps. Set to
\code{0} to skip augmentation.}

\item{verbose}{Logical if \code{TRUE}, emits progress messages.}
}
\value{
A list with the following elements:
  \tabular{llll}{
    \code{state} \cr 
      \tab A list with the following elements: \cr
      \tab \code{expression} \cr 
      \tab \tab \tab Numeric matrix with non-negative expression values. \cr
      \tab \code{features}   \cr 
      \tab \tab \tab A data.frame with feature meta-data for rows of expression. \cr
      \tab \code{samples}    \cr 
      \tab \tab \tab A data.frame with observation meta-data for columns of expression. \cr
    \code{log} \cr 
      \tab A data.frame logging statistics for each fit. \cr
  }
}
\description{
Impute missing values using \code{glmnet} package.
}
\details{
Imputes missing values using a \code{glmnet::cv.glmnet} model trained 
    using observations in which the feature was expressed. Iterates through 
    features beginning with those having fewest missing values. If 
    \code{aug_steps > 0}, augments observations with affine transormed versions.
    This is meant to enable extrapolation outside of observed intensity 
    range. If \code{aug_steps > 0}, assumes expression data have been previously
    \code{log(x+1)} transformed. If you want \code{0} to be considered missing, 
    and have \code{0} in the data, do something like 
    \code{exprs[exprs \%in\% 0] <- NA} prior to imputing. Augmentation uses 
    \code{f.aug_mult()}.
}
\examples{
  \dontrun{
    exprs[exprs \%in\% 0] <- NA
    state <- list(expression=exprs)
    config <- list(log_file="")
    state2 <- f.impute_glmnet(state, config, impute_quantile=0.01)
    exprs2 <- state2$expression

    state2 <- f.impute_glmnet(state, config, nfolds=3, alpha=0.5, aug_steps=2)
    state2 <- f.impute_glmnet(state, config)
    exprs2 <- state2$expression
  }
}
