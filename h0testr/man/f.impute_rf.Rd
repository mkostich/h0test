% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute.R
\name{f.impute_rf}
\alias{f.impute_rf}
\title{Impute missing values using \code{randomForest}.}
\usage{
f.impute_rf(
  state,
  config,
  is_log_transformed = NULL,
  f_imp = f.impute_unif_sample_lod,
  ntree = 100,
  mtry = NULL,
  aug_mult = 0.33,
  aug_add = 0,
  aug_steps = 3,
  verbose = T
)
}
\arguments{
\item{state}{A list with elements like that returned by \code{f.read_data()}:
  \tabular{ll}{
    \code{expression} \cr \tab Numeric matrix with non-negative expression values. \cr
    \code{features}   \cr \tab A data.frame with feature meta-data for rows of expression. \cr
    \code{samples}    \cr \tab A data.frame with observation meta-data for columns of expression. \cr
  } 
It is assumed that state$expression has been previously \code{log2(x+1)} transformed.}

\item{config}{List with configuration values. Does not use any keys, so can pass empty list.}

\item{is_log_transformed}{Logical scalar: if \code{state$expression} has 
been log transformed.}

\item{f_imp}{Function to use for initial rough imputation.}

\item{ntree}{Numeric (greater than 0) number of trees in random forest.
\code{randomForest} \code{ntree} parameter.}

\item{mtry}{Numeric (greater than 0) number of features to sample at each 
node in each tree. \code{randomForest} \code{mtry} parameter.}

\item{aug_mult}{Numeric affine shift for training data augmentation.}

\item{aug_add}{Numeric affine shift for training data augmentation.}

\item{aug_steps}{Numeric (non-negative) number of augmentation steps. Set to
\code{0} to skip augmentation.}

\item{verbose}{Logical if TRUE, emits progress messages.}
}
\value{
A list with the following elements:
  \tabular{llll}{
    \code{state} \cr 
      \tab A list with the following elements: \cr
      \tab \code{expression} \cr 
      \tab \tab \tab Numeric matrix with non-negative expression values. \cr
      \tab \code{features}   \cr 
      \tab \tab \tab A data.frame with feature meta-data for rows of expression. \cr
      \tab \code{samples}    \cr 
      \tab \tab \tab A data.frame with observation meta-data for columns of expression. \cr
    \code{log} \cr 
      \tab A data.frame logging statistics for each fit. \cr
  }
}
\description{
Impute missing values using the \code{randomForest} package.
}
\details{
Imputes missing values using a \code{randomForest::randomForest} 
  model trained using observations in which the feature was expressed. 
  Iterates through features beginning with those having fewest missing 
  values. If \code{aug_steps > 0}, augments observations with affine 
  transormed versions. This is meant to enable extrapolation outside of 
  observed intensity range. If \code{aug_steps > 0}, assumes expression 
  data have been previously \code{log(x+1)} transformed. If you want 
  \code{0} to be considered missing, and have \code{0} in the data, do 
  something like \code{exprs[exprs \%in\% 0] <- NA} prior to imputing. 
  Augmentation uses \code{f.augment_affine()}.
}
\examples{
set.seed(101)
exprs <- h0testr::f.sim1(n_obs=20, n_feats=30)$mat
exprs <- log2(exprs + 1)
feats <- data.frame(feature_id=rownames(exprs))
samps <- data.frame(observation_id=colnames(exprs))
state <- list(expression=exprs, features=feats, samples=samps)
config <- list()

## untransformed example:
out <- h0testr::f.impute_rf(state, config, is_log_transformed=FALSE, verbose=FALSE)
state2 <- out$state
summary(c(state$expression))    ## Note number of NAs
summary(c(state2$expression))   ## Note number of NAs
head(state$expression)
round(head(state2$expression))
print(out$log)

## log-transformed example:
state$expression <- log2(state$expression + 1)
out <- h0testr::f.impute_rf(state, config, is_log_transformed=TRUE, verbose=FALSE)
state2 <- out$state
summary(c(state$expression))    ## Note number of NAs
summary(c(state2$expression))   ## Note number of NAs
head(state$expression)
round(head(state2$expression))
print(out$log)
}
